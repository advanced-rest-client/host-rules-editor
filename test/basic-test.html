<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../../neon-animation/web-animations.html">
    <script src="model.js"></script>
    <link rel="import" href="../host-rules-editor.html">
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <host-rules-editor></host-rules-editor>
      </template>
    </test-fixture>

    <test-fixture id="NoAuto">
      <template>
        <host-rules-editor no-auto></host-rules-editor>
      </template>
    </test-fixture>

    <script>
    const TEST_RULES = [{
      from: 'host-from',
      to: 'host-to',
      enabled: true,
      comment: 'test-comment',
      _id: 'test-id'
    }];

    suite('Initialization', function() {
      test('hasItems is false by default', function() {
        const element = fixture('NoAuto');
        assert.isFalse(element.hasItems);
      });

      test('Is not loading right after initialization', function() {
        const element = fixture('NoAuto');
        assert.isUndefined(element.loading);
      });

      test('dataUnavailable is computed', function() {
        const element = fixture('NoAuto');
        assert.isTrue(element.dataUnavailable);
      });

      test('rulesTesterOpened is undefined', function() {
        const element = fixture('NoAuto');
        assert.isUndefined(element.rulesTesterOpened);
      });

      test('Eventually calls for model data', (done) => {
        const element = fixture('Basic');
        element.addEventListener('host-rules-list', function f(e) {
          element.removeEventListener('host-rules-list', f);
          e.preventDefault();
          e.detail.result = Promise.resolve();
          done();
        });
      });

      test('Wont\'t call for model data when no-auto', (done) => {
        const element = fixture('NoAuto');
        const spy = sinon.spy();
        element.addEventListener('host-rules-list', spy);
        Polymer.RenderStatus.afterNextRender(element, () => {
          assert.isFalse(spy.called);
          done();
        });
      });
    });

    suite('refresh()', function() {
      let element;
      setup(function(done) {
        element = fixture('NoAuto');
        flush(() => done());
      });

      test('Sets the loading property', function() {
        element.refresh();
        assert.isTrue(element.loading);
      });

      test('Sends host-rules-list custom event', function() {
        const spy = sinon.spy();
        element.addEventListener('host-rules-list', spy);
        element.refresh();
        assert.isTrue(spy.calledOnce);
      });

      test('host-rules-list event is cancelable', function(done) {
        element.addEventListener('host-rules-list', function clb(e) {
          element.removeEventListener('host-rules-list', clb);
          assert.isTrue(e.cancelable);
          done();
        });
        element.refresh();
      });

      test('Sets hasItems property (empty data)', function() {
        return element.refresh()
        .then(() => {
          assert.isFalse(element.hasItems);
        });
      });

      test('Sets dataUnavailable property (empty data)', function() {
        return element.refresh()
        .then(() => {
          assert.isTrue(element.dataUnavailable);
        });
      });

      test('Renders the tutorial', function(done) {
        element.refresh()
        .then(() => {
          flush(() => {
            const tutorial = element.shadowRoot.querySelector('tutorial-toast');
            assert.isTrue(tutorial.opened);
            done();
          });
        });
      });

      test('Renders empty info screen', function(done) {
        element.refresh()
        .then(() => {
          flush(() => {
            const node = element.shadowRoot.querySelector('.empty-screen');
            assert.ok(node);
            done();
          });
        });
      });

      test('Sets hasItems property (with data)', function() {
        window.HOST_RULES = TEST_RULES;
        return element.refresh()
        .then(() => {
          assert.isTrue(element.hasItems);
        });
      });

      test('Sets dataUnavailable property (with data)', function() {
        window.HOST_RULES = TEST_RULES;
        return element.refresh()
        .then(() => {
          assert.isFalse(element.dataUnavailable);
        });
      });

      test('The tutorial is closed with data', function(done) {
        window.HOST_RULES = TEST_RULES;
        element.refresh()
        .then(() => {
          flush(() => {
            const node = element.shadowRoot.querySelector('tutorial-toast');
            assert.isFalse(node.opened);
            done();
          });
        });
      });

      test('Info screen is not rendered', function(done) {
        window.HOST_RULES = TEST_RULES;
        element.refresh()
        .then(() => {
          flush(() => {
            const node = element.shadowRoot.querySelector('.empty-screen');
            assert.equal(node.style.display, 'none');
            done();
          });
        });
      });
    });

    suite('appendRule()', function() {
      let element;
      setup(function() {
        element = fixture('Basic');
      });

      test('Should append an empty rule', function() {
        assert.isUndefined(element.items, 'items is undefined');
        element.appendRule();
        assert.typeOf(element.items, 'array', 'items is an array');
        assert.lengthOf(element.items, 1, 'array has one item');
      });

      test('Appending empty item does not fire host-rules-changed custom event', function(done) {
        const spy = sinon.spy();
        element.addEventListener('host-rules-changed', spy);
        element.appendRule();
        setTimeout(function() {
          assert.isFalse(spy.called);
          done();
        }, 300);
      });
    });

    suite('host-rules-changed custom event', function() {
      let element;
      setup(function() {
        element = fixture('Basic');
        element.refresh = function() {};
        element.appendRule();
        TEST_RULES[0].from = 'host-from';
      });

      test('host-rules-changed is not fired when missing data', function(done) {
        const spy = sinon.spy();
        element.addEventListener('host-rules-changed', spy);
        element.set(['items', 0, 'from'], 'test');
        setTimeout(function() {
          assert.isFalse(spy.called);
          done();
        }, 300);
      });

      test('host-rules-changed is fired when updating model', function(done) {
        element.addEventListener('host-rules-changed', function clb() {
          element.removeEventListener('host-rules-changed', clb);
          done();
        });
        element.set(['items', 0, 'from'], 'test-from');
        element.set(['items', 0, 'to'], 'test-to');
      });

      test('host-rules-changed contains generated ID', function(done) {
        element.addEventListener('host-rules-changed', function clb(e) {
          element.removeEventListener('host-rules-changed', clb);
          assert.typeOf(e.detail.rule._id, 'string');
          done();
        });
        element.set(['items', 0, 'from'], 'test-from');
        element.set(['items', 0, 'to'], 'test-to');
      });

      test('host-rules-changed contains rule data', function(done) {
        element.addEventListener('host-rules-changed', function clb(e) {
          element.removeEventListener('host-rules-changed', clb);
          assert.equal(e.detail.rule.from, 'test-from');
          assert.equal(e.detail.rule.to, 'test-to');
          assert.equal(e.detail.rule.comment, '');
          assert.isTrue(e.detail.rule.enabled);
          done();
        });
        element.set(['items', 0, 'from'], 'test-from');
        element.set(['items', 0, 'to'], 'test-to');
      });

      function fireUpdated(cancelable) {
        cancelable = cancelable || false;
        const ev = new CustomEvent('host-rules-changed', {
          bubbles: true,
          cancelable: cancelable,
          detail: {
            rule: {
              from: 'host-from-updated',
              to: 'host-to',
              enabled: true,
              comment: 'test-comment',
              _id: 'test-id'
            }
          }
        });
        document.body.dispatchEvent(ev);
      }

      test('Appends a rule form the model event', function() {
        assert.lengthOf(element.items, 1, 'Contains an item');
        fireUpdated();
        assert.lengthOf(element.items, 2, 'New item is appended');
        assert.equal(element.items[1]._id, 'test-id');
      });

      test('Updates existing rule', function() {
        element.items = TEST_RULES;
        fireUpdated();
        assert.equal(element.items[0].from, 'host-from-updated');
      });

      test('Ignores cancelable event', function() {
        element.items = TEST_RULES;
        fireUpdated(true);
        assert.equal(element.items[0].from, 'host-from');
      });
    });

    suite('host-rules-deleted custom event', function() {
      let element;
      setup(function(done) {
        element = fixture('Basic');
        element.refresh = function() {};
        element._setLoading(false);
        element.items = [{
          from: 'host-from',
          to: 'host-to',
          enabled: true,
          comment: 'test-comment',
          _id: 'test-id'
        }];
        flush(() => done());
      });

      function deleteItem() {
        const item = element.shadowRoot.querySelector('host-rules-editor-item');
        const button = item.shadowRoot.querySelector('[data-action="delete"]');
        button.click();
      }

      test('Fires the event', function(done) {
        element.addEventListener('host-rules-deleted', function clb() {
          element.removeEventListener('host-rules-deleted', clb);
          done();
        });
        deleteItem();
      });

      test('host-rules-changed contains rule ID', function(done) {
        element.addEventListener('host-rules-deleted', function clb(e) {
          element.removeEventListener('host-rules-deleted', clb);
          assert.equal(e.detail.id, 'test-id');
          done();
        });
        deleteItem();
      });

      function fireDeleted(id, cancelable) {
        cancelable = cancelable || false;
        const ev = new CustomEvent('host-rules-deleted', {
          bubbles: true,
          cancelable: cancelable,
          detail: {
            id: id
          }
        });
        document.body.dispatchEvent(ev);
      }

      test('Deletes existing rule from the list', function() {
        fireDeleted('test-id');
        assert.lengthOf(element.items, 0, 'Rule is deleted');
      });

      test('Ignores unknown rule', function() {
        fireDeleted('non-existing');
        assert.lengthOf(element.items, 1, 'Rule is not deleted');
      });

      test('Ignores cancelable event', function() {
        fireDeleted('test-id', true);
        assert.lengthOf(element.items, 1, 'Rule is not deleted');
      });
    });

    suite('_closeMainMenu()', function() {
      let element;
      setup(function(done) {
        element = fixture('NoAuto');
        flush(() => {
          element.$.mainMenu.opened = true;
          element.$.mainMenuOptions.selected = 1;
          done();
        });
      });

      test('Closes the menu', function() {
        element._closeMainMenu();
        assert.isFalse(element.$.mainMenu.opened);
      });

      test('Resets the selection', function() {
        element._closeMainMenu();
        assert.equal(element.$.mainMenuOptions.selected, -1);
      });
    });

    suite('_dispatchExport()', function() {
      const dest = 'file';
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });

      test('Dispatches the event', function() {
        const spy = sinon.spy();
        element.addEventListener('export-data', spy);
        element._dispatchExport(dest);
        assert.isTrue(spy.called);
      });

      test('Returns the  event', function() {
        const e = element._dispatchExport(dest);
        assert.typeOf(e, 'customevent');
        assert.equal(e.type, 'export-data');
      });

      test('The event is composed', function() {
        const e = element._dispatchExport(dest);
        if (e.composed !== undefined) {
          assert.isTrue(e.composed);
        }
      });

      test('The event bubbles', function() {
        const e = element._dispatchExport(dest);
        assert.isTrue(e.bubbles);
      });

      test('The event is cancelable', function() {
        const e = element._dispatchExport(dest);
        assert.isTrue(e.cancelable);
      });

      test('The event has destination', function() {
        const e = element._dispatchExport(dest);
        assert.equal(e.detail.destination, dest);
      });

      test('The event has file', function() {
        const e = element._dispatchExport(dest);
        assert.equal(e.detail.file, 'arc-host-rules.json');
      });

      test('The event has type', function() {
        const e = element._dispatchExport(dest);
        assert.equal(e.detail.type, 'arc-export');
      });

      test('The event has data', function() {
        const e = element._dispatchExport(dest);
        assert.deepEqual(e.detail.data, {
          'host-rules': true
        });
      });
    });

    suite('Export actions', () => {
      let element;
      setup(function() {
        element = fixture('NoAuto');
      });

      test('Calls _sendExport() with argument for _onExportAll()', () => {
        const spy = sinon.spy(element, '_sendExport');
        element._onExportAll();
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'file');
      });

      test('Calls _sendExport() with argument for _onExportAllDrive()', () => {
        const spy = sinon.spy(element, '_sendExport');
        element._onExportAllDrive();
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'drive');
      });
    });
    </script>
  </body>
</html>
