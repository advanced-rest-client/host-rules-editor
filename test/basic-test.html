<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="model.js"></script>
    <link rel="import" href="../host-rules-editor.html">
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <host-rules-editor></host-rules-editor>
      </template>
    </test-fixture>

    <script>
    const TEST_RULES = [{
      from: 'host-from',
      to: 'host-to',
      enabled: true,
      comment: 'test-comment',
      _id: 'test-id'
    }];

    suite('basic', function() {
      let element;
      setup(function() {
        element = fixture('Basic');
      });

      test('hasItems is false by default', function() {
        assert.isFalse(element.hasItems);
      });

      test('Is not loading right after initialization', function() {
        assert.isUndefined(element.loading);
      });

      test('dataUnavailable is computed', function() {
        assert.isTrue(element.dataUnavailable);
      });

      test('rulesTesterOpened is undefined', function() {
        assert.isUndefined(element.rulesTesterOpened);
      });
    });

    suite('refresh()', function() {
      let element;
      setup(function() {
        element = fixture('Basic');
      });

      test('Sets the loading property', function() {
        element.refresh();
        assert.isTrue(element.loading);
      });

      test('Sends host-rules-list custom event', function() {
        let spy = sinon.spy();
        element.addEventListener('host-rules-list', spy);
        element.refresh();
        assert.isTrue(spy.calledOnce);
      });

      test('host-rules-list event is cancelable', function(done) {
        element.addEventListener('host-rules-list', function clb(e) {
          element.removeEventListener('host-rules-list', clb);
          assert.isTrue(e.cancelable);
          done();
        });
        element.refresh();
      });

      test('Sets hasItems property (empty data)', function() {
        return element.refresh()
        .then(() => {
          assert.isFalse(element.hasItems);
        });
      });

      test('Sets dataUnavailable property (empty data)', function() {
        return element.refresh()
        .then(() => {
          assert.isTrue(element.dataUnavailable);
        });
      });

      test('Renders the tutorial', function(done) {
        element.refresh()
        .then(() => {
          flush(() => {
            const tutorial = element.shadowRoot.querySelector('tutorial-toast');
            assert.isTrue(tutorial.opened);
            done();
          });
        });
      });

      test('Renders empty info screen', function(done) {
        element.refresh()
        .then(() => {
          flush(() => {
            const node = element.shadowRoot.querySelector('.empty-screen');
            assert.ok(node);
            done();
          });
        });
      });

      test('Sets hasItems property (with data)', function() {
        window.HOST_RULES = TEST_RULES;
        return element.refresh()
        .then(() => {
          assert.isTrue(element.hasItems);
        });
      });

      test('Sets dataUnavailable property (with data)', function() {
        window.HOST_RULES = TEST_RULES;
        return element.refresh()
        .then(() => {
          assert.isFalse(element.dataUnavailable);
        });
      });

      test('The tutorial is closed with data', function(done) {
        window.HOST_RULES = TEST_RULES;
        element.refresh()
        .then(() => {
          flush(() => {
            const node = element.shadowRoot.querySelector('tutorial-toast');
            assert.isFalse(node.opened);
            done();
          });
        });
      });

      test('Info screen is not rendered', function(done) {
        window.HOST_RULES = TEST_RULES;
        element.refresh()
        .then(() => {
          flush(() => {
            const node = element.shadowRoot.querySelector('.empty-screen');
            assert.notOk(node);
            done();
          });
        });
      });
    });

    suite('appendRule()', function() {
      let element;
      setup(function() {
        element = fixture('Basic');
      });

      test('Should append an empty rule', function() {
        assert.isUndefined(element.items, 'items is undefined');
        element.appendRule();
        assert.typeOf(element.items, 'array', 'items is an array');
        assert.lengthOf(element.items, 1, 'array has one item');
      });

      test('Appending empty item does not fire host-rules-changed custom event', function(done) {
        const spy = sinon.spy();
        element.addEventListener('host-rules-changed', spy);
        element.appendRule();
        setTimeout(function() {
          assert.isFalse(spy.called);
          done();
        }, 300);
      });
    });

    suite('host-rules-changed custom event', function() {
      let element;
      setup(function() {
        element = fixture('Basic');
        element.refresh = function() {};
        element.appendRule();
        TEST_RULES[0].from = 'host-from';
      });

      test('host-rules-changed is not fired when missing data', function(done) {
        const spy = sinon.spy();
        element.addEventListener('host-rules-changed', spy);
        element.set(['items', 0, 'from'], 'test');
        setTimeout(function() {
          assert.isFalse(spy.called);
          done();
        }, 300);
      });

      test('host-rules-changed is fired when updating model', function(done) {
        element.addEventListener('host-rules-changed', function clb() {
          element.removeEventListener('host-rules-changed', clb);
          done();
        });
        element.set(['items', 0, 'from'], 'test-from');
        element.set(['items', 0, 'to'], 'test-to');
      });

      test('host-rules-changed contains generated ID', function(done) {
        element.addEventListener('host-rules-changed', function clb(e) {
          element.removeEventListener('host-rules-changed', clb);
          assert.typeOf(e.detail.rule._id, 'string');
          done();
        });
        element.set(['items', 0, 'from'], 'test-from');
        element.set(['items', 0, 'to'], 'test-to');
      });

      test('host-rules-changed contains rule data', function(done) {
        element.addEventListener('host-rules-changed', function clb(e) {
          element.removeEventListener('host-rules-changed', clb);
          assert.equal(e.detail.rule.from, 'test-from');
          assert.equal(e.detail.rule.to, 'test-to');
          assert.equal(e.detail.rule.comment, '');
          assert.isTrue(e.detail.rule.enabled);
          done();
        });
        element.set(['items', 0, 'from'], 'test-from');
        element.set(['items', 0, 'to'], 'test-to');
      });

      function fireUpdated(cancelable) {
        cancelable = cancelable || false;
        const ev = new CustomEvent('host-rules-changed', {
          bubbles: true,
          cancelable: cancelable,
          detail: {
            rule: {
              from: 'host-from-updated',
              to: 'host-to',
              enabled: true,
              comment: 'test-comment',
              _id: 'test-id'
            }
          }
        });
        document.body.dispatchEvent(ev);
      }

      test('Appends a rule form the model event', function() {
        assert.lengthOf(element.items, 1, 'Contains an item');
        fireUpdated();
        assert.lengthOf(element.items, 2, 'New item is appended');
        assert.equal(element.items[1]._id, 'test-id');
      });

      test('Updates existing rule', function() {
        element.items = TEST_RULES;
        fireUpdated();
        assert.equal(element.items[0].from, 'host-from-updated');
      });

      test('Ignores cancelable event', function() {
        element.items = TEST_RULES;
        fireUpdated(true);
        assert.equal(element.items[0].from, 'host-from');
      });
    });

    suite('host-rules-deleted custom event', function() {
      let element;
      setup(function(done) {
        element = fixture('Basic');
        element.refresh = function() {};
        element._setLoading(false);
        element.items = [{
          from: 'host-from',
          to: 'host-to',
          enabled: true,
          comment: 'test-comment',
          _id: 'test-id'
        }];
        flush(() => done());
      });

      function deleteItem() {
        const item = element.shadowRoot.querySelector('host-rules-editor-item');
        const button = item.shadowRoot.querySelector('[data-action="delete"]');
        button.click();
      }

      test('Fires the event', function(done) {
        element.addEventListener('host-rules-deleted', function clb() {
          element.removeEventListener('host-rules-deleted', clb);
          done();
        });
        deleteItem();
      });

      test('host-rules-changed contains rule ID', function(done) {
        element.addEventListener('host-rules-deleted', function clb(e) {
          element.removeEventListener('host-rules-deleted', clb);
          assert.equal(e.detail.id, 'test-id');
          done();
        });
        deleteItem();
      });

      function fireDeleted(id, cancelable) {
        cancelable = cancelable || false;
        const ev = new CustomEvent('host-rules-deleted', {
          bubbles: true,
          cancelable: cancelable,
          detail: {
            id: id
          }
        });
        document.body.dispatchEvent(ev);
      }

      test('Deletes existing rule from the list', function() {
        fireDeleted('test-id');
        assert.lengthOf(element.items, 0, 'Rule is deleted');
      });

      test('Ignores unknown rule', function() {
        fireDeleted('non-existing');
        assert.lengthOf(element.items, 1, 'Rule is not deleted');
      });

      test('Ignores cancelable event', function() {
        fireDeleted('test-id', true);
        assert.lengthOf(element.items, 1, 'Rule is not deleted');
      });
    });
    </script>
  </body>
</html>
